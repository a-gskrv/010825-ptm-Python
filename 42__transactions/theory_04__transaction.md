### Что такое транзакция

**Транзакция** — это логическая группа операций с базой данных, которая выполняется **атомарно**.

> Атомарность = либо все операции выполняются, либо ни одной.

Транзакция гарантирует **ACID** свойства:

| Свойство                              | Что значит                                                                                                           |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **A** – Atomicity (атомарность)       | Все операции внутри транзакции выполняются как единое целое. Если хоть одна неудачна, откатывается всё.              |
| **C** – Consistency (согласованность) | После транзакции база остаётся в согласованном состоянии (с учетом всех ограничений, типа CHECK, FOREIGN KEY и т.д.) |
| **I** – Isolation (изолированность)   | Одновременно работающие транзакции не мешают друг другу.                                                             |
| **D** – Durability (надёжность)       | После успешного commit изменения сохраняются даже при сбое сервера.                                                  |

**Пример из жизни**: перевод денег с одного счёта на другой.

* Если списали со счёта A, но не зачислили на B → это ошибка.
* Транзакция гарантирует: либо списание + зачисление, либо ничего.

---

### Транзакции в Python (mysql-connector)

В Python с `mysql-connector` транзакция управляется через **соединение (connection)**:

```python
import mysql.connector

conn = mysql.connector.connect(**dbconfig_write)

# 1. Отключаем autocommit, чтобы включить транзакцию вручную
conn.autocommit = False

cursor = conn.cursor()

try:
    # 2. Выполняем несколько операций
    cursor.execute("UPDATE SHOP SET amount = amount + %s", (100,))
    cursor.execute("UPDATE CUSTOMER SET amount = amount - %s", (100,))

    # 3. Подтверждаем изменения
    conn.commit()
    print("✅ Транзакция успешна")

except mysql.connector.Error as e:
    # 4. Если что-то пошло не так — откатываем все изменения
    conn.rollback()
    print("❌ Ошибка транзакции:", e)

finally:
    cursor.close()
    conn.close()
```

### Объяснение шагов

1. **Отключаем autocommit**
 * Для гарантированного выполнения транзакции лучше явно запретить автокоммит: `autocommit = False`.

2. **Выполняем операции**
 * Все `cursor.execute` теперь находятся в рамках одной транзакции.

3. **COMMIT**
 * Если все операции прошли успешно, `conn.commit()` сохраняет изменения навсегда.

4. **ROLLBACK**
 * Если возникает ошибка (например, нарушен `CHECK`), вызываем `conn.rollback()`,  
 * и база возвращается в состояние **до транзакции**.

---

### Пример 

Ограничение (`amount >= 0`) заложено в самой таблице:

```sql
CREATE TABLE CUSTOMER (
    amount DECIMAL(10,2) DEFAULT 0,
    CHECK (amount >= 0)
)
```


```python
cursor.execute("UPDATE SHOP SET amount = amount + %s", (price,))
cursor.execute("UPDATE CUSTOMER SET amount = amount - %s", (price,))
conn.commit()
```

В этом случае:

* Если покупатель не имеет денег (`CUSTOMER.amount - price < 0`) → MySQL выбрасывает ошибку CHECK.
* Исключение ловится в Python → вызывается `conn.rollback()`.
* **Итог:** деньги продавцу не зачислены, баланс покупателя не изменился.


---

### Рекомендации по использованию транзакций в Python

1. **Используйте блок `try-except-finally`**

   * Всегда делай `rollback()` при ошибке
   * Всегда закрывай соединение

2. **Не смешивайте транзакции с `autocommit = Tru`e**

   * Тогда COMMIT / ROLLBACK будут игнорироваться

3. **Лучше конкретизировать ошибки DB**

   * Для CHECK constraint или FOREIGN KEY
   * Но можно просто `rollback` на любое исключение

4. **Минимизируйте время транзакции**

   * Держите соединение открытым минимально
   * Чем дольше транзакция, тем выше риск блокировок


